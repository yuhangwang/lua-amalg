<!DOCTYPE html>

<html>
<head>
  <title>amalg.lua</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>amalg.lua</h1>
              </div>
          </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p><strong>Amalg</strong> is a Lua tool for bundling a Lua script and dependent
Lua modules in a single <code>.lua</code> file for easier distribution.</p>
<p>Features:</p>
<ul>
<li>Pure Lua (compatible with Lua 5.1 and up), no external
dependencies. (Even works for modules using the deprecated
<code>module</code> function.)</li>
<li>You don’t have to take care of the order in which the modules
are <code>require</code>d.</li>
<li>Can embed compiled C modules.</li>
<li>Can collect <code>require</code>d Lua (and C) modules automatically.</li>
</ul>
<p>What it doesn’t do:</p>
<ul>
<li>It does not compile to bytecode. Use <code>luac</code> for that yourself,
or take a look at <a href="http://matthewwild.co.uk/projects/squish/home">squish</a>, or <a href="http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/5.1/luac.lua">luac.lua</a>.</li>
<li>It doesn’t do static analysis of Lua code to collect <code>require</code>d
modules. That won’t work reliably anyway in a dynamic language!
You can write your own program for that (e.g. using the output
of <code>luac -p -l</code>), or use <a href="http://matthewwild.co.uk/projects/squish/home">squish</a>, or <a href="http://lua-users.org/lists/lua-l/2012-02/msg00609.html">soar</a> instead.</li>
<li>It will not compress, minify, obfuscate your Lua source code,
or any of the other things <a href="http://matthewwild.co.uk/projects/squish/home">squish</a> can do.</li>
<li>It doesn’t handle the dependencies of C modules, so it is best
used on C modules without dependencies (e.g. LuaSocket, LFS,
etc.).</li>
</ul>
<p>The <code>amalg.lua</code> <a href="http://github.com/siffiejoe/lua-amalg">source code</a> is available on GitHub, and is
released under the <a href="http://opensource.org/licenses/MIT">MIT license</a>. You can view <a href="http://siffiejoe.github.io/lua-amalg/">a nice HTML
version</a> of this file rendered by <a href="http://jashkenas.github.io/docco/">Docco</a> on the GitHub
pages.</p>
<p>As already mentioned, there are alternatives to this program: See
<a href="http://matthewwild.co.uk/projects/squish/home">squish</a>, <a href="http://loop.luaforge.net/release/preload.html">LOOP</a>, <a href="http://lua-users.org/lists/lua-l/2012-02/msg00609.html">soar</a>, <a href="http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/5.1/luac.lua">luac.lua</a>, and
<a href="https://github.com/akavel/scissors/blob/master/tools/bundle/bundle.lua">bundle.lua</a> (and probably some more).</p>
<h2 id="getting-started">Getting Started</h2>
<p>You can bundle a collection of Lua modules in a single file by
calling the <code>amalg.lua</code> script and passing the module names on the
command line:</p>
<pre><code>./amalg.lua module1 module2
</code></pre><p>The modules are collected using <code>package.path</code>, so they have to be
available there. The resulting merged Lua code will be written to
the standard output stream. You have to actually run the resulting
code to make the embedded Lua modules available for <code>require</code>.</p>
<p>You can specify an output file to use instead of the standard
output stream:</p>
<pre><code>./amalg.lua -o out.lua module1 module2
</code></pre><p>You can also embed the main script of your application in the
merged Lua code as well. Of course, the embedded Lua modules can be
<code>require</code>d from the embedded main script.</p>
<pre><code>./amalg.lua -o out.lua -s main.lua module1 module2
</code></pre><p>If you want the original file names and line numbers to appear in
error messages, you have to activate debug mode. This will require
slightly more memory, though.</p>
<pre><code>./amalg.lua -o out.lua -d -s main.lua module1 module2
</code></pre><p>To collect all Lua (and C) modules used by a program, you can load
the <code>amalg.lua</code> script as a module, and it will intercept calls to
<code>require</code> (more specifically the Lua module searcher) and save the
necessary Lua module names in a file <code>amalg.cache</code> in the current
directory:</p>
<pre><code>lua -lamalg main.lua
</code></pre><p>Multiple calls will add to this module cache. But don’t access it
from multiple concurrent processes (the cache isn’t protected
against race conditions)!</p>
<p>You can use the cache (in addition to all module names given on the
command line) using the <code>-c</code> flag:</p>
<pre><code>./amalg.lua -o out.lua -s main.lua -c
</code></pre><p>However, this will only embed the Lua modules. To also embed the C
modules (both from the cache and from the command line), you have
to specify the <code>-x</code> flag:</p>
<pre><code>./amalg.lua -o out.lua -s main.lua -c -x
</code></pre><p>This will make the amalgamated script platform- and Lua version
dependent, obviously!</p>
<p>To fix a compatibility issue with Lua 5.1’s vararg handling,
<code>amalg.lua</code> by default adds a local alias to the global <code>arg</code> table
to every loaded module. If for some reason you don’t want that, use
the <code>-a</code> flag (but be aware that in Lua 5.1 with <code>LUA_COMPAT_VARARG</code>
defined (the default) your modules can only access the global <code>arg</code>
table as <code>_G.arg</code>).</p>
<pre><code>./amalg.lua -o out.lua -a -s main.lua -c
</code></pre><p>That’s it. For further info consult the source.</p>
<h2 id="implementation">Implementation</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>The name of the script used in warning messages and the name of the
cache file can be configured here by changing these local
variables:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> prog = <span class="hljs-string">"amalg.lua"</span>
<span class="hljs-keyword">local</span> cache = <span class="hljs-string">"amalg.cache"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Wrong use of the command line may cause warnings to be printed to
the console. This function is for printing those warnings:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warn</span><span class="hljs-params">( ... )</span></span>
  <span class="hljs-built_in">io</span>.stderr:write( <span class="hljs-string">"WARNING "</span>, prog, <span class="hljs-string">": "</span> )
  <span class="hljs-keyword">local</span> n = <span class="hljs-built_in">select</span>( <span class="hljs-string">'#'</span>, ... )
  <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">local</span> v = <span class="hljs-built_in">tostring</span>( (<span class="hljs-built_in">select</span>( i, ... )) )
    <span class="hljs-built_in">io</span>.stderr:write( v, i == n <span class="hljs-keyword">and</span> <span class="hljs-string">'\n'</span> <span class="hljs-keyword">or</span> <span class="hljs-string">'\t'</span> )
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Function for parsing the command line of <code>amalg.lua</code> when invoked
as a script. The following flags are supported:</p>
<ul>
<li><code>-o &lt;file&gt;</code>: specify output file (default is <code>stdout</code>)</li>
<li><code>-s &lt;file&gt;</code>: specify main script to bundle</li>
<li><code>-c</code>: add the modules listed in the cache file <code>amalg.cache</code></li>
<li><code>-d</code>: enable debug mode (file names and line numbers in error
messages will point to the original location)</li>
<li><code>-a</code>: do <em>not</em> apply the <code>arg</code> fix (local alias for the global
<code>arg</code> table)</li>
<li><code>-x</code>: also embed compiled C modules</li>
<li><code>--</code>: stop parsing command line flags (all remaining arguments
are considered module names)</li>
</ul>
<p>Other arguments are assumed to be module names. For an inconsistent
command line (e.g. duplicate options) a warning is printed to the
console.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse_cmdline</span><span class="hljs-params">( ... )</span></span>
  <span class="hljs-keyword">local</span> modules, afix, use_cache, cmods, dbg, script, oname = {}, <span class="hljs-keyword">true</span>

  <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set_oname</span><span class="hljs-params">( v )</span></span>
    <span class="hljs-keyword">if</span> v <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">if</span> oname <span class="hljs-keyword">then</span>
        warn( <span class="hljs-string">"Resetting output file `"</span>..oname..<span class="hljs-string">"'! Using `"</span>..v..<span class="hljs-string">"' now!"</span> )
      <span class="hljs-keyword">end</span>
      oname = v
    <span class="hljs-keyword">else</span>
      warn( <span class="hljs-string">"Missing argument for -o option!"</span> )
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set_script</span><span class="hljs-params">( v )</span></span>
    <span class="hljs-keyword">if</span> v <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">if</span> script <span class="hljs-keyword">then</span>
        warn( <span class="hljs-string">"Resetting main script `"</span>..script..<span class="hljs-string">"'! Using `"</span>..v..<span class="hljs-string">"' now!"</span> )
      <span class="hljs-keyword">end</span>
      script = v
    <span class="hljs-keyword">else</span>
      warn( <span class="hljs-string">"Missing argument for -s option!"</span> )
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">local</span> i, n = <span class="hljs-number">1</span>, <span class="hljs-built_in">select</span>( <span class="hljs-string">'#'</span>, ... )
  <span class="hljs-keyword">while</span> i &lt;= n <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">local</span> a = <span class="hljs-built_in">select</span>( i, ... )
    <span class="hljs-keyword">if</span> a == <span class="hljs-string">"--"</span> <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">for</span> j = i+<span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span>
        modules[ <span class="hljs-built_in">select</span>( j, ... ) ] = <span class="hljs-keyword">true</span>
      <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">elseif</span> a == <span class="hljs-string">"-o"</span> <span class="hljs-keyword">then</span>
      i = i + <span class="hljs-number">1</span>
      set_oname( i &lt;= n <span class="hljs-keyword">and</span> <span class="hljs-built_in">select</span>( i, ... ) )
    <span class="hljs-keyword">elseif</span> a == <span class="hljs-string">"-s"</span> <span class="hljs-keyword">then</span>
      i = i + <span class="hljs-number">1</span>
      set_script( i &lt;= n <span class="hljs-keyword">and</span> <span class="hljs-built_in">select</span>( i, ... ) )
    <span class="hljs-keyword">elseif</span> a == <span class="hljs-string">"-c"</span> <span class="hljs-keyword">then</span>
      use_cache = <span class="hljs-keyword">true</span>
    <span class="hljs-keyword">elseif</span> a == <span class="hljs-string">"-x"</span> <span class="hljs-keyword">then</span>
      cmods = <span class="hljs-keyword">true</span>
    <span class="hljs-keyword">elseif</span> a == <span class="hljs-string">"-d"</span> <span class="hljs-keyword">then</span>
      dbg = <span class="hljs-keyword">true</span>
    <span class="hljs-keyword">elseif</span> a == <span class="hljs-string">"-a"</span> <span class="hljs-keyword">then</span>
      afix = <span class="hljs-keyword">false</span>
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">local</span> prefix = a:sub( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> )
      <span class="hljs-keyword">if</span> prefix == <span class="hljs-string">"-o"</span> <span class="hljs-keyword">then</span>
        set_oname( a:sub( <span class="hljs-number">3</span> ) )
      <span class="hljs-keyword">elseif</span> prefix == <span class="hljs-string">"-s"</span> <span class="hljs-keyword">then</span>
        set_script( a:sub( <span class="hljs-number">3</span> ) )
      <span class="hljs-keyword">elseif</span> a:sub( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) == <span class="hljs-string">"-"</span> <span class="hljs-keyword">then</span>
        warn( <span class="hljs-string">"Unknown command line flag: "</span>..a )
      <span class="hljs-keyword">else</span>
        modules[ a ] = <span class="hljs-keyword">true</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    i = i + <span class="hljs-number">1</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> oname, script, dbg, afix, use_cache, cmods, modules
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>The approach for embedding precompiled Lua files is different from
the normal way of pasting the source code, so this function detects
whether a file is a binary file (Lua bytecode starts with the <code>ESC</code>
character):</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_bytecode</span><span class="hljs-params">( path )</span></span>
  <span class="hljs-keyword">local</span> f, res = <span class="hljs-built_in">io</span>.open( path, <span class="hljs-string">"rb"</span> ), <span class="hljs-keyword">false</span>
  <span class="hljs-keyword">if</span> f <span class="hljs-keyword">then</span>
    res = f:read( <span class="hljs-number">1</span> ) == <span class="hljs-string">"\027"</span>
    f:close()
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> res
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Read the whole contents of a file into memory without any
processing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readfile</span><span class="hljs-params">( path, is_bin )</span></span>
  <span class="hljs-keyword">local</span> f = <span class="hljs-built_in">assert</span>( <span class="hljs-built_in">io</span>.open( path, is_bin <span class="hljs-keyword">and</span> <span class="hljs-string">"rb"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"r"</span> ) )
  <span class="hljs-keyword">local</span> s = <span class="hljs-built_in">assert</span>( f:read( <span class="hljs-string">"*a"</span> ) )
  f:close()
  <span class="hljs-keyword">return</span> s
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Lua files to be embedded into the resulting amalgamation are read
into memory in a single go, because under some circumstances (e.g.
binary chunks, shebang lines, <code>-d</code> command line flag) some
preprocessing/escaping is necessary. This function reads a whole
Lua file and returns the contents as a Lua string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readluafile</span><span class="hljs-params">( path )</span></span>
  <span class="hljs-keyword">local</span> is_bin = is_bytecode( path )
  <span class="hljs-keyword">local</span> s = readfile( path, is_bin )
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_bin <span class="hljs-keyword">then</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Shebang lines are only supported by Lua at the very beginning
of a source file, so they have to be removed before the source
code can be embedded in the output.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    s = s:gsub( <span class="hljs-string">"^#[^\n]*"</span>, <span class="hljs-string">""</span> )
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> s, is_bin
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Lua 5.1’s <code>string.format(&quot;%q&quot;)</code> doesn’t convert all control
characters to decimal escape sequences like the newer Lua versions
do. This might cause problems on some platforms (i.e. Windows) when
loading a Lua script (opened in text mode) that contains binary
code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qformat</span><span class="hljs-params">( code )</span></span>
  <span class="hljs-keyword">local</span> s = (<span class="hljs-string">"%q"</span>):format( code )
  <span class="hljs-keyword">return</span> (s:gsub( <span class="hljs-string">"(%c)(%d?)"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( c, d )</span></span>
    <span class="hljs-keyword">if</span> c ~= <span class="hljs-string">"\n"</span> <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">return</span> (d~=<span class="hljs-string">""</span> <span class="hljs-keyword">and</span> <span class="hljs-string">"\\%03d"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"\\%d"</span>):format( c:byte() )..d
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span> ))
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>When the <code>-c</code> command line flag is given, the contents of the cache
file <code>amalg.cache</code> are used to specify the modules to embed. This
function is used to load the cache file:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readcache</span><span class="hljs-params">()</span></span>
  <span class="hljs-keyword">local</span> chunk = <span class="hljs-built_in">loadfile</span>( cache, <span class="hljs-string">"t"</span>, {} )
  <span class="hljs-keyword">if</span> chunk <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">setfenv</span> <span class="hljs-keyword">then</span> <span class="hljs-built_in">setfenv</span>( chunk, {} ) <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">local</span> result = chunk()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>( result ) == <span class="hljs-string">"table"</span> <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">return</span> result
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>When loaded as a module, <code>amalg.lua</code> collects Lua modules and C
modules that are <code>require</code>d and updates the cache file
<code>amalg.cache</code>. This function saves the updated cache contents to
the file:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writecache</span><span class="hljs-params">( c )</span></span>
  <span class="hljs-keyword">local</span> f = <span class="hljs-built_in">assert</span>( <span class="hljs-built_in">io</span>.open( cache, <span class="hljs-string">"w"</span> ) )
  f:write( <span class="hljs-string">"return {\n"</span> )
  <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>( c ) <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>( k ) == <span class="hljs-string">"string"</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>( v ) == <span class="hljs-string">"string"</span> <span class="hljs-keyword">then</span>
      f:write( <span class="hljs-string">"  [ "</span>, qformat( k ), <span class="hljs-string">" ] = "</span>, qformat( v ), <span class="hljs-string">",\n"</span> )
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
  f:write( <span class="hljs-string">"}\n"</span> )
  f:close()
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>The standard Lua function <code>package.searchpath</code> available in Lua 5.2
and up is used to locate the source files for Lua modules and
library files for C modules. For Lua 5.1 a backport is provided.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> searchpath = <span class="hljs-built_in">package</span>.searchpath
<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> searchpath <span class="hljs-keyword">then</span>
  <span class="hljs-keyword">local</span> delim = <span class="hljs-built_in">package</span>.config:match( <span class="hljs-string">"^(.-)\n"</span> ):gsub( <span class="hljs-string">"%%"</span>, <span class="hljs-string">"%%%%"</span> )

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">searchpath</span><span class="hljs-params">( name, path )</span></span>
    <span class="hljs-keyword">local</span> pname = name:gsub( <span class="hljs-string">"%."</span>, delim ):gsub( <span class="hljs-string">"%%"</span>, <span class="hljs-string">"%%%%"</span> )
    <span class="hljs-keyword">local</span> msg = {}
    <span class="hljs-keyword">for</span> subpath <span class="hljs-keyword">in</span> path:gmatch( <span class="hljs-string">"[^;]+"</span> ) <span class="hljs-keyword">do</span>
      <span class="hljs-keyword">local</span> fpath = subpath:gsub( <span class="hljs-string">"%?"</span>, pname )
      <span class="hljs-keyword">local</span> f = <span class="hljs-built_in">io</span>.open( fpath, <span class="hljs-string">"r"</span> )
      <span class="hljs-keyword">if</span> f <span class="hljs-keyword">then</span>
        f:close()
        <span class="hljs-keyword">return</span> fpath
      <span class="hljs-keyword">end</span>
      msg[ #msg+<span class="hljs-number">1</span> ] = <span class="hljs-string">"\n\tno file '"</span>..fpath..<span class="hljs-string">"'"</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">nil</span>, <span class="hljs-built_in">table</span>.concat( msg )
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>This is the main function for the use case where <code>amalg.lua</code> is run
as a script. It parses the command line, creates the output files,
collects the module and script sources, and writes the amalgamated
source.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">amalgamate</span><span class="hljs-params">( ... )</span></span>
  <span class="hljs-keyword">local</span> oname, script, dbg, afix, use_cache, cmods, modules = parse_cmdline( ... )
  <span class="hljs-keyword">local</span> errors = {}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>When instructed to on the command line, the cache file is loaded,
and the modules are added to the ones listed on the command line.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> use_cache <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">local</span> c = readcache()
    <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>( c <span class="hljs-keyword">or</span> {} ) <span class="hljs-keyword">do</span>
      modules[ k ] = v
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">local</span> out = <span class="hljs-built_in">io</span>.stdout
  <span class="hljs-keyword">if</span> oname <span class="hljs-keyword">then</span>
    out = <span class="hljs-built_in">assert</span>( <span class="hljs-built_in">io</span>.open( oname, <span class="hljs-string">"w"</span> ) )
  <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>If a main script is to be embedded, this includes a shebang line
so that the resulting amalgamation can be run without explicitly
specifying the interpreter on unixoid systems.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> script <span class="hljs-keyword">then</span>
    out:write( <span class="hljs-string">"#!/usr/bin/env lua\n\ndo\n\n"</span> )
  <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Every module given on the command line and/or in the cache file
is processed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">for</span> m,t <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>( modules ) <span class="hljs-keyword">do</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Only Lua modules are handled for now, so modules that are
definitely C modules are skipped and handled later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> t ~= <span class="hljs-string">"C"</span> <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">local</span> path, msg  = searchpath( m, <span class="hljs-built_in">package</span>.path )
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path <span class="hljs-keyword">and</span> (t == <span class="hljs-string">"L"</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> cmods) <span class="hljs-keyword">then</span></pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>The module is supposed to be a Lua module, but it cannot
be found, so an error is raised.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-built_in">error</span>( <span class="hljs-string">"module `"</span>..m..<span class="hljs-string">"' not found:"</span>..msg )
      <span class="hljs-keyword">elseif</span> <span class="hljs-keyword">not</span> path <span class="hljs-keyword">then</span></pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Module possibly is a C module, so it is tried again later.
But the current error message is saved in case the given
name isn’t a C module either.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        modules[ m ], errors[ m ] = <span class="hljs-string">"C"</span>, msg
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">local</span> bytes, is_bin = readluafile( path )
        <span class="hljs-keyword">if</span> is_bin <span class="hljs-keyword">or</span> dbg <span class="hljs-keyword">then</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Precompiled Lua modules are loaded via the standard Lua
function <code>load</code> (or <code>loadstring</code> in Lua 5.1). Since this
preserves file name and line number information, this
approach is used for all files if the debug mode is active
(<code>-d</code> command line option).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          out:write( <span class="hljs-string">"package.preload[ "</span>, qformat( m ),
                     <span class="hljs-string">" ] = assert( (loadstring or load)(\n"</span>,
                     qformat( bytes ), <span class="hljs-string">"\n, '@'.."</span>,
                     qformat( path ), <span class="hljs-string">" ) )\n\n"</span> )
        <span class="hljs-keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Under normal circumstances Lua files are pasted into a
new anonymous vararg function, which then is put into
<code>package.preload</code> so that <code>require</code> can find it. Each
function gets its own <code>_ENV</code> upvalue (on Lua 5.2+), and
special care is taken that <code>_ENV</code> always is the first
upvalue (important for the <code>module</code> function on Lua 5.2).
Lua 5.1 compiled with <code>LUA_COMPAT_VARARG</code> (the default) will
create a local <code>arg</code> variable to emulate the vararg handling
of Lua 5.0. This might interfere with Lua modules that access
command line arguments via the <code>arg</code> global. As a workaround
<code>amalg.lua</code> adds a local alias to the global <code>arg</code> table
unless the <code>-a</code> command line flag is specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          out:write( <span class="hljs-string">"do\nlocal _ENV = _ENV\n"</span>,
                     <span class="hljs-string">"package.preload[ "</span>, qformat( m ),
                     <span class="hljs-string">" ] = function( ... ) "</span>,
                     afix <span class="hljs-keyword">and</span> <span class="hljs-string">"local arg = _G.arg;\n"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"_ENV = _ENV;\n"</span>,
                     bytes, <span class="hljs-string">"\nend\nend\n\n"</span> )
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>If the <code>-x</code> command line flag is active, C modules are embedded
as strings, and written out to temporary files on demand by the
amalgamated code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> cmods <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">local</span> nfuncs = {}</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>To make the loading of C modules more robust, the necessary
global functions are saved in upvalues (because user-supplied
code might be run before a C module is loaded). The upvalues
are local to a <code>do ... end</code> block, so they aren’t visible in
the main script code.</p>
<p>On Windows the result of <code>os.tmpname()</code> is not an absolute
path by default. If that’s the case the value of the <code>TMP</code>
environment variable is prepended to make it absolute.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">local</span> prefix = <span class="hljs-string">[=[
local assert = assert
local newproxy = newproxy
local getmetatable = assert( getmetatable )
local setmetatable = assert( setmetatable )
local os_tmpname = assert( os.tmpname )
local os_getenv = assert( os.getenv )
local os_remove = assert( os.remove )
local io_open = assert( io.open )
local string_match = assert( string.match )
local string_sub = assert( string.sub )
local package_loadlib = assert( package.loadlib )

local dirsep = package.config:match( "^([^\n]+)" )
local tmpdir
local function newdllname()
  local tmpname = assert( os_tmpname() )
  if dirsep == "\\" then
    if not string_match( tmpname, "[\\/][^\\/]+[\\/]" ) then
      tmpdir = tmpdir or assert( os_getenv( "TMP" ),
                                 "could not detect temp directory" )
      local first = string_sub( tmpname, 1, 1 )
      local hassep = first == "\\" or first == "/"
      tmpname = tmpdir..((hassep) and "" or "\\")..tmpname
    end
  end
  return tmpname
end
local dllnames = {}

]=]</span>
    <span class="hljs-keyword">for</span> m,t <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>( modules ) <span class="hljs-keyword">do</span>
      <span class="hljs-keyword">if</span> t == <span class="hljs-string">"C"</span> <span class="hljs-keyword">then</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Try a search strategy similar to the standard C module
searcher first and then the all-in-one strategy to locate
the library files for the C modules to embed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">local</span> path, msg  = searchpath( m, <span class="hljs-built_in">package</span>.cpath )
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path <span class="hljs-keyword">then</span>
          errors[ m ] = (errors[ m ] <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>) .. msg
          path, msg = searchpath( m:gsub( <span class="hljs-string">"%..*$"</span>, <span class="hljs-string">""</span> ), <span class="hljs-built_in">package</span>.cpath )
          <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path <span class="hljs-keyword">then</span>
            <span class="hljs-built_in">error</span>( <span class="hljs-string">"module `"</span>..m..<span class="hljs-string">"' not found:"</span>..errors[ m ]..msg )
          <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">local</span> qpath = qformat( path )</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Build the symbol(s) to look for in the dynamic library.
There may be multiple candidates because of optional
version information in the module names and the different
approaches of the different Lua versions in handling that.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">local</span> openf = m:gsub( <span class="hljs-string">"%."</span>, <span class="hljs-string">"_"</span> )
        <span class="hljs-keyword">local</span> openf1, openf2 = openf:match( <span class="hljs-string">"^([^%-]*)%-(.*)$"</span> )</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>The amalgamation of C modules is split into two parts:
One part generates a temporary file name for the C library
and writes the binary code stored in the amalgamation to
that file, while the second loads the resulting dynamic
library using <code>package.loadlib</code>. The split is necessary
because multiple modules could be loaded from the same
library, and the amalgamated code has to simulate that.
Shared dynamic libraries are embedded only once.</p>
<p>The temporary dynamic library files may or may not be
cleaned up when the amalgamated code exits (this probably
works on POSIX machines (all Lua versions) and on Windows
with Lua 5.1). The reason is that starting with version 5.2
Lua ensures that libraries aren’t unloaded before normal
user-supplied <code>__gc</code> metamethods have run to avoid a case
where such a metamethod would call an unloaded C function.
As a consequence the amalgamated code tries to remove the
temporary library files <em>before</em> they are actually
unloaded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nfuncs[ path ] <span class="hljs-keyword">then</span>
          <span class="hljs-keyword">local</span> code = readfile( path, <span class="hljs-keyword">true</span> )
          nfuncs[ path ] = <span class="hljs-keyword">true</span>
          <span class="hljs-keyword">local</span> qcode = qformat( code )
          out:write( prefix, <span class="hljs-string">"dllnames[ "</span>, qpath, <span class="hljs-string">[=[ ] = function()
  local dll = newdllname()
  local f = assert( io_open( dll, "wb" ) )
  f:write( ]=]</span>, qcode, <span class="hljs-string">[=[ )
  f:close()
  local sentinel = newproxy and newproxy( true )
                            or setmetatable( {}, { __gc = true } )
  getmetatable( sentinel ).__gc = function() os_remove( dll ) end
  dllnames[ ]=]</span>, qpath, <span class="hljs-string">[=[ ] = function()
    local _ = sentinel
    return dll
  end
  return dll
end

]=]</span> )
          prefix = <span class="hljs-string">""</span>
        <span class="hljs-keyword">end</span> <span class="hljs-comment">-- shared libary not embedded already</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Add a function to <code>package.preload</code> to load the temporary
DLL or shared object file. This function tries to mimic the
behavior of Lua 5.3 which is to strip version information
from the module name at the end first, and then at the
beginning if that failed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">local</span> qm = qformat( m )
        out:write( <span class="hljs-string">"package.preload[ "</span>, qm, <span class="hljs-string">" ] = function()\n"</span>,
                   <span class="hljs-string">"  local dll = dllnames[ "</span>, qpath, <span class="hljs-string">" ]()\n"</span> )
        <span class="hljs-keyword">if</span> openf1 <span class="hljs-keyword">then</span>
          out:write( <span class="hljs-string">"  local loader = package_loadlib( dll, "</span>,
                     qformat( <span class="hljs-string">"luaopen_"</span>..openf1 ), <span class="hljs-string">" )\n"</span>,
                     <span class="hljs-string">"  if not loader then\n"</span>,
                     <span class="hljs-string">"    loader = assert( package_loadlib( dll, "</span>,
                     qformat( <span class="hljs-string">"luaopen_"</span>..openf2 ),
                     <span class="hljs-string">" ) )\n  end\n"</span> )
        <span class="hljs-keyword">else</span>
          out:write( <span class="hljs-string">"  local loader = assert( package_loadlib( dll, "</span>,
                     qformat( <span class="hljs-string">"luaopen_"</span>..openf ), <span class="hljs-string">" ) )\n"</span> )
        <span class="hljs-keyword">end</span>
        out:write( <span class="hljs-string">"  return loader( "</span>, qm, <span class="hljs-string">", dll )\nend\n\n"</span> )
      <span class="hljs-keyword">end</span> <span class="hljs-comment">-- is a C module</span>
    <span class="hljs-keyword">end</span> <span class="hljs-comment">-- for all given module names</span>
  <span class="hljs-keyword">end</span> <span class="hljs-comment">-- if cmods</span></pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>If a main script is specified on the command line (<code>-s</code> flag),
embed it now that all dependent modules are available to
<code>require</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> script <span class="hljs-keyword">then</span>
    out:write( <span class="hljs-string">"end\n\n"</span> )
    <span class="hljs-keyword">local</span> bytes, is_bin = readluafile( script )
    <span class="hljs-keyword">if</span> is_bin <span class="hljs-keyword">or</span> dbg <span class="hljs-keyword">then</span>
      out:write( <span class="hljs-string">"assert( (loadstring or load)(\n"</span>,
                 qformat( bytes ), <span class="hljs-string">"\n, '@'.."</span>,
                 qformat( script ), <span class="hljs-string">" ) )( ... )\n\n"</span> )
    <span class="hljs-keyword">else</span>
      out:write( bytes )
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">if</span> oname <span class="hljs-keyword">then</span>
    out:close()
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>If <code>amalg.lua</code> is loaded as a module, it intercepts <code>require</code> calls
(more specifically calls to the searcher functions) to collect all
<code>require</code>d module names and store them in the cache. The cache file
<code>amalg.cache</code> is updated when the program terminates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collect</span><span class="hljs-params">()</span></span>
  <span class="hljs-keyword">local</span> searchers = <span class="hljs-built_in">package</span>.searchers <span class="hljs-keyword">or</span> <span class="hljs-built_in">package</span>.loaders</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>When the searchers table has been modified, it is unknown which
elements in the table to replace, so <code>amalg.lua</code> bails out with
an error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-built_in">assert</span>( #searchers == <span class="hljs-number">4</span>, <span class="hljs-string">"package.searchers has been modified"</span> )
  <span class="hljs-keyword">local</span> c = readcache() <span class="hljs-keyword">or</span> {}</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>The updated cache is written to disk when the following value is
garbage collected, which should happen at <code>lua_close()</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">local</span> sentinel = newproxy <span class="hljs-keyword">and</span> newproxy( <span class="hljs-keyword">true</span> )
                            <span class="hljs-keyword">or</span> <span class="hljs-built_in">setmetatable</span>( {}, { __gc = <span class="hljs-keyword">true</span> } )
  <span class="hljs-built_in">getmetatable</span>( sentinel ).__gc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> writecache( c ) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">local</span> lua_searcher = searchers[ <span class="hljs-number">2</span> ]
  <span class="hljs-keyword">local</span> c_searcher = searchers[ <span class="hljs-number">3</span> ]
  <span class="hljs-keyword">local</span> aio_searcher = searchers[ <span class="hljs-number">4</span> ] <span class="hljs-comment">-- all in one searcher</span>

  <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rv_handler</span><span class="hljs-params">( tag, mname, ... )</span></span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>( (...) ) == <span class="hljs-string">"function"</span> <span class="hljs-keyword">then</span>
      c[ mname ] = tag
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> ...
  <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>The replacement searchers just forward to the original versions,
but also update the cache if the search was successful.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  searchers[ <span class="hljs-number">2</span> ] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( ... )</span></span>
    <span class="hljs-keyword">local</span> _ = sentinel <span class="hljs-comment">-- make sure that sentinel is an upvalue</span>
    <span class="hljs-keyword">return</span> rv_handler( <span class="hljs-string">"L"</span>, ..., lua_searcher( ... ) )
  <span class="hljs-keyword">end</span>
  searchers[ <span class="hljs-number">3</span> ] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( ... )</span></span>
    <span class="hljs-keyword">local</span> _ = sentinel <span class="hljs-comment">-- make sure that sentinel is an upvalue</span>
    <span class="hljs-keyword">return</span> rv_handler( <span class="hljs-string">"C"</span>, ..., c_searcher( ... ) )
  <span class="hljs-keyword">end</span>
  searchers[ <span class="hljs-number">4</span> ] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( ... )</span></span>
    <span class="hljs-keyword">local</span> _ = sentinel <span class="hljs-comment">-- make sure that sentinel is an upvalue</span>
    <span class="hljs-keyword">return</span> rv_handler( <span class="hljs-string">"C"</span>, ..., aio_searcher( ... ) )
  <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Since calling <code>os.exit</code> might skip the <code>lua_close()</code> call, the
<code>os.exit</code> function is monkey-patched to also save the updated
cache to the cache file on disk.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>( <span class="hljs-built_in">os</span> ) == <span class="hljs-string">"table"</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>( <span class="hljs-built_in">os</span>.exit ) == <span class="hljs-string">"function"</span> <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">local</span> os_exit = <span class="hljs-built_in">os</span>.exit
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">os.exit</span><span class="hljs-params">( ... )</span></span>
      writecache( c )
      <span class="hljs-keyword">return</span> os_exit( ... )
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>To determine whether <code>amalg.lua</code> is run as a script or loaded as a
module it uses the debug module to walk the call stack looking for
a <code>require</code> call. If such a call is found, <code>amalg.lua</code> has been
<code>require</code>d as a module.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_script</span><span class="hljs-params">()</span></span>
  <span class="hljs-keyword">local</span> i = <span class="hljs-number">3</span>
  <span class="hljs-keyword">local</span> info = <span class="hljs-built_in">debug</span>.getinfo( i, <span class="hljs-string">"f"</span> )
  <span class="hljs-keyword">while</span> info <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> info.func == <span class="hljs-built_in">require</span> <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
    <span class="hljs-keyword">end</span>
    i = i + <span class="hljs-number">1</span>
    info = <span class="hljs-built_in">debug</span>.getinfo( i, <span class="hljs-string">"f"</span> )
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>This checks whether <code>amalg.lua</code> has been called as a script or
loaded as a module and acts accordingly, by calling the
corresponding main function:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">if</span> is_script() <span class="hljs-keyword">then</span>
  amalgamate( ... )
<span class="hljs-keyword">else</span>
  collect()
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
